#### 排序专栏



#### 0、算法概述

**0.1 基于比较的排序算法**

* 冒泡排序 Bubble Sort
* 快速排序
* 选择排序
  * 简单选择排序
  * 堆排序
* 插入排序
  * 简单插入排序
  * 希尔排序
* 归并排序

**0.2 非比较的排序算法**

* 计数排序
* 桶排序
* 基数排序

<img src="https://img2018.cnblogs.com/blog/849589/201903/849589-20190306165258970-1789860540.png" alt="img" style="zoom: 50%;" />



**0.3 时间复杂度分析**

<img src="https://images2018.cnblogs.com/blog/849589/201804/849589-20180402133438219-1946132192.png" alt="img" style="zoom: 50%;" />





> 假设
>
> 排序函数声明为 int[] sort(int[] nums)，nums长度为n
>
> 返回的数组是 递增的数组



#### 1、冒泡排序

***

**1.1 算法描述**

>  nums[0]与nums[1]进行比较，若nums[0]>nums[1]，则交换nums[0]和nums[1]，否则不做操作。
>
> 然后用nums[1]与nums[2]比较，注意：此处的nums[1]是最初的数组中**nums[0]与nums[1]的较大者**
>
> 若nums[2]>nums[3]，则交换nums[2]和nums[3]，否则不做操作。
>
> 同理比较n-1次，最终nums[n-1]为nums数组中的最大值。
>
> 同理再次进行这样的循环，从nums[0]到nums[n-1]，到nums[n-2]，到nums[n-3]...到nums[1]
>
> **n-1次循环**后，nums数组最终为递增的数组。
>
> **每次循环未排序数组中的最大值都会冒泡到未排序数组的末尾**，所以这个排序叫冒泡排序

**1.2 代码实现**

```java
    public static int[] bubbleSort(int[] nums){
        if(nums == null || nums.length < 2){
            return nums;
        }
        for(int i = 0; i < nums.length; i++){
            for(int j = 0; j < nums.length-i-1; j++){
                if(nums[j] > nums[j+1]){
        			int tmp = nums[j];
        			nums[j] = nums[j+1];
        			nums[j+1] = tmp;                
                }
            }
        }

        return nums;
    }
```



#### 2、插入排序

***

**2.1 算法描述**

> 假设nums从0到k的元素为已排好序的，则将第k+1个元素插入到已排序的序列中（从后到前依次比较），则已排序序列的长度则会加1
>
> 初始，可认为第一个元素为长度为1的已排序序列，然后插入第2个元素、第三个元素...第n个元素，最终会得到一个长度为n的已排序序列，排序完成
>
> 注意，插入元素的代码应尽量简洁且减少开销

**2.2 代码实现**

```java
	public static int[] insertSort(int[] nums){
        if(nums == null || nums.length < 2){
            return nums;
        }
        for(int i = 1; i < nums.length; i++){
            int index = i;
            int temp = nums[i];
            for(int j = i-1; j >= 0 && nums[j] > nums[j+1]; j--){
                nums[j+1] = nums[j];
                index = j;
            }
            nums[index] = temp;  //index为最后找到的合适的位置
        }
        return nums;
    }
```



#### 3、希尔排序

***

1959年Shell发明，第一个突破O(n2)的排序算法，是简单插入排序的改进版。它与插入排序的不同之处在于，它会优先比较距离较远的元素。希尔排序又叫**缩小增量排序**。

##### 3.1 算法描述

* 设定一个序列：（k1, k2, k3...k<sub>n</sub>），要求k<sub>n == 1，k<sub>i</sub> > k<sub>j</sub>(i < j)
* 从序列中选取一个k<sub>i</sub>, 将nums分为ki份，如（0, k<sub>i</sub>, 2k<sub>i</sub>, 3k<sub>i</sub>...），（1, 1+k<sub>i</sub>,2+k<sub>i</sub>,3+k<sub>i</sub>...）(k<sub>i</sub>-1, 2k<sub>i</sub>-1, 3k<sub>i</sub>-1...)
* 对每个子序列进行一次插入排序
* 选取k<sub>i+1d</sub重复步骤2，直至所有的k均被使用
* 易知k == 1时，即为一次普通的插入排序



**3.2 代码实现**

```java
public static int[] shellSort(int[] nums){
        int length = nums.length;
        if(nums == null || length < 2){
            return nums;
        }

        int temp, index;
        for(int k = length / 2; k > 1; k /= 2){
            //以k为增量进行k次插排
            for(int start = 0; start < k; start++){
                //此处每一次循环为一次以k为增量的插排
                for(int i = start; i < length; i++){
                    temp = nums[i];
                    index = i;
                    for(int j = i-1; j >= 0 && nums[j] > nums[j+1]; j--){
                        nums[j+1] = nums[j];
                        index = j;
                    }
                    nums[index] = temp;
                }
            }
        }

        return nums;
    }
```

**3.3 算法分析**

希尔排序的时间复杂度计算很麻烦，但是可以从感性的角度理解为什么希尔排序很快

如果将一个数组中，如果nums[i] > nums[j] (i < j)，则将其视为一个逆序（因为排序目标是升序）

容易看出排序的本质就是消除逆序数，可以证明对于随机数组，逆序数是O(N^2^)的

而如果采用“交换相邻元素”的办法来消除逆序，每次正好只消除一个，因此必须执行O(N^2^)的交换次数，这就是为啥冒泡、插入等算法只能到平方级别的原因

反过来，基于交换元素的排序要想突破这个下界，必须执行一些比较，交换相隔比较远的元素，使得一次交换能消除一个以上的逆序，希尔、快排、堆排等等算法都是交换比较远的元素，只不过规则各不同罢了

(摘选自[知乎](https://www.zhihu.com/question/24637339))



#### 4、 快速排序(Quick Sort)

***

**4.1 算法描述**



##### 4.2 代码实现

```java

```





**部分内容、图片来源**

1. [十大经典排序算法（动图演示）](https://www.cnblogs.com/onepixel/p/7674659.html)

2. 