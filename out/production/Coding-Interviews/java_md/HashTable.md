### HashMap



#### HashMap 和 HashTable 区别

* HashMap是线程不安全的，HashTable是线程安全的
* HashMap的key可以为null，HashTable不行
* HashMap是HasnTable的轻量版，所以性能更好，功能大部分都是一致的



#### java7中的HashMap

**实现原理**

* 数据

  * 默认容量：16
  * 默认负载因子loadFactar：0.75
  * 存储数据的方式：数组加链表（即数组对应表，链表为解决冲突的方式）

* 方法

  * 构造方法：初始化容量和负载因子，知道有数据put时再开辟table

  * get方法：调用Object.hashCode(key)获取key的hash值，再通过取模运算（与运算实现）求得该项应该在的位置，然后遍历链表，找到数据

  * put方法：类似get方法找到表项，在链表中插入数据（插在头部，节省时间）

  * resize方法：每次put之后，计算一下表的大小是否达到阈值（负载因子  *  表的容量），若达到了则开辟一个新的数组，其大小为原数组容量的两倍，然后将原数组中所有的元素全部移到新数组中（重新计算下标）

  * rehash
    通过上面的分析可以看出，不同的键的的hashcode仅仅只能通过低位来区分。高位的信息没有被充分利用。极端情况就是：所有的hashCode低位全相等，而高位不相等，这大大加大了哈希冲突，降低了HashMap的性能。

    为了防止这种情况的出现，HashMap它使用一个supplemental hash function对键的hashCode再进行了一个supplemental hash ，将最终的hash值作为键的hash值来进行桶的位置映射（也就是说JDK团队在为我们这群程序员加性能保险Orz）。这个过程叫做再哈希(rehash)。

    经过一个supplemental hash过程后，能保证海明距离为常数的不同的hashcode有一个哈希冲突次数上界（装载因子为0.75的时候，大约是8次）。

* 特点

  * 通过链接法处理冲突
  * 数据量超过阈值时创建新数组并将原数据转移到新数组

* 问题

  * 在并发环境下，如果两个线程同时对一个HashMap进行扩容，有可能会出现环形链表，从而可能造成死循环的情况，即**死锁**
  * 安全隐患：许多String类型的变量的hashcode（移位的hash函数）是相同的，如果有黑客刻意上传大量经过设计的hashcode相同的字符串，可能导致哈希表的有些链表非常长，从而导致get和put的时间复杂度骤升。（因为java7中是用链表链接法解决冲突的）（后来sun公司针对这个问题做了一些改进，不再使用string默认的hashcode函数）



**分离链接法的算法分析**



#### Java8中HashMap的改进

* 数组 + 链表/红黑树

  当链表长度过长时（默认阈值为8），将链表转成红黑树

* 扩容时插入顺序的改进

  因为新表的大小为是原表的两倍，故求index的时候，举例：和1111进行与操作变成了和11111进行与操作，所以新的index只有两种可能：要么和原值相同，要么是原值+表长的一半

  在扩容时进行一些操作，保证插入顺序不变，降低发生死锁的概率（但仍不是线程安全的）



**HashMap的容量为什么必须是2的次方数？**

* 在hash函数可以通过位运算（&）求值，减少时间消耗

* 由于2^n^-1的后n-1位一定都是1，在做与运算时可以保证Table的每一个下标都可能被取到

  如果有1位为0，则运算结果的对应位也一定为0，导致部分表项的位置永远不会被取到，造成空间浪费

  



**String类型的hashcode函数**

```java
	public int hashCode() {
        int h = hash;
        if (h == 0 && value.length > 0) {
            char val[] = value;

            for (int i = 0; i < value.length; i++) {
                h = 31 * h + val[i];
            }
            hash = h;
        }
        return h;
    }
```



**为什么用31作为乘子？**

1. 大家都喜欢选一个质数（传统）
2. 而且31不大不小，既不会像2、3一样导致冲突现象明显，也不会像101一样过大，可能导致指数运算后数据溢出（尽管101作为乘子时，hash函数可能映射得更为均匀）
3. 为什么不用37、41、43呢，是因为31与2^5 相邻，可以通过位运算来优化乘法运算